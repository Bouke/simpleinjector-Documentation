<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advanced Scenarios &mdash; Simple Injector 2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Simple Injector 2 documentation" href="index.html" />
    <link rel="prev" title="Using Simple Injector" href="using.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="using.html" title="Using Simple Injector"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Simple Injector 2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="advanced-scenarios">
<h1>Advanced Scenarios<a class="headerlink" href="#advanced-scenarios" title="Permalink to this headline">¶</a></h1>
<p>Although its name may not imply it, <em>Simple Injector</em> is capable of handling many advanced scenarios. Either through writing custom code, copying  code from this wiki, or via the extension points that can be found in the <em>SimpleInjector.Extensions</em> namespace of the core library.</p>
<div class="note container">
<strong>Note</strong>: this documentation is specific for <em>Simple Injector version 2.0</em> and up. Look <a class="reference external" href="https://simpleinjector.codeplex.com/wikipage?title=Advanced-scenarios&amp;version=48">here</a> for 1.x specific documentation.</div>
<div class="note container">
<strong>Note</strong>: After including the <em>SimpleInjector.dll</em> in your project, you will have to add the <em>SimpleInjector.Extensions</em> namespace to your code to be able to use the majority of features that are presented in this wiki page.</div>
<p>This page discusses the following subjects:</p>
<ul class="simple">
<li><a class="reference internal" href="#generics"><em>Generics</em></a></li>
<li><a class="reference internal" href="#id2"><em>Batch registration / Automatic registration</em></a></li>
<li><a class="reference internal" href="#id3"><em>Registration of open generic types</em></a></li>
<li><a class="reference internal" href="#id5"><em>Unregistered type resolution</em></a></li>
<li><a class="reference internal" href="#id7"><em>Context based injection / Contextual binding</em></a></li>
<li><a class="reference internal" href="#decorators"><em>Decorators</em></a></li>
<li><a class="reference internal" href="#interception"><em>Interception</em></a></li>
<li><a class="reference internal" href="#property-injection"><em>Property injection</em></a></li>
<li><a class="reference internal" href="#id18"><em>Covariance and Contravariance</em></a></li>
<li><a class="reference internal" href="#plugins"><em>Registering plugins dynamically</em></a></li>
</ul>
<div class="section" id="generics">
<span id="id1"></span><h2>Generics<a class="headerlink" href="#generics" title="Permalink to this headline">¶</a></h2>
<p>.NET has superior support for generic programming and Simple Injector has been designed to make full use of it. Simple Injector arguably has the most advanced support for generics of all DI libraries. Simple Injector can handle any generic type and implementing patterns such as decorator, mediator, strategy and chain of responsibility is simple.</p>
<p>Aspect Oriented Programming is easy with Simple Injector&#8217;s advanced support for generics. Generic decorators with generic type constraints can be registered with a single line of code and can be applied conditionally using predicates. Simple Injector can handle open generic types, closed generic types and partially-closed generic types. The sections below provides more detail on Simple Injector&#8217;s support for generic typing:</p>
<ul class="simple">
<li><a class="reference internal" href="#id2"><em>Batch registration of non-generic types based on an open-generic interface</em></a></li>
<li><a class="reference internal" href="#id3"><em>Registering open generic types and working with partially-closed types</em></a></li>
<li><a class="reference internal" href="#decorators"><em>Registration of generic decorators</em></a></li>
<li><a class="reference internal" href="#id18"><em>Resolving Covariant/Contravariant types</em></a></li>
</ul>
</div>
<div class="section" id="batch-automatic-registration">
<span id="id2"></span><span id="batch-registration"></span><h2>Batch / Automatic registration<a class="headerlink" href="#batch-automatic-registration" title="Permalink to this headline">¶</a></h2>
<p>Batch or automatic registration is a way of registering a set of related types in one go based on some convention. This features removes the need to constantly update the containers configuration each and every time a new type is added. The following example show a series of manually registered repositories:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserRepository</span><span class="p">,</span> <span class="n">SqlUserRepository</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ICustomerRepository</span><span class="p">,</span> <span class="n">SqlCustomerRepository</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IOrderRepository</span><span class="p">,</span> <span class="n">SqlOrderRepository</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IProductRepository</span><span class="p">,</span> <span class="n">SqlProductRepository</span><span class="p">&gt;();</span>
<span class="c1">// and the list goes on...</span>
</pre></div>
</div>
<p>To prevent having to change the container for each new repository we can use the non-generic registration overloads in combination with a simple LINQ query:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">repositoryAssembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">SqlUserRepository</span><span class="p">).</span><span class="n">Assembly</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">registrations</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">type</span> <span class="k">in</span> <span class="n">repositoryAssembly</span><span class="p">.</span><span class="n">GetExportedTypes</span><span class="p">()</span>
    <span class="k">where</span> <span class="n">type</span><span class="p">.</span><span class="n">Namespace</span> <span class="p">==</span> <span class="s">&quot;MyComp.MyProd.BL.SqlRepositories&quot;</span>
    <span class="k">where</span> <span class="n">type</span><span class="p">.</span><span class="n">GetInterfaces</span><span class="p">().</span><span class="n">Any</span><span class="p">()</span>
    <span class="k">select</span> <span class="k">new</span>
    <span class="p">{</span>
        <span class="n">Service</span> <span class="p">=</span> <span class="n">type</span><span class="p">.</span><span class="n">GetInterfaces</span><span class="p">().</span><span class="n">Single</span><span class="p">(),</span>
        <span class="n">Implementation</span> <span class="p">=</span> <span class="n">type</span>
    <span class="p">};</span>

<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">reg</span> <span class="k">in</span> <span class="n">registrations</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">Service</span><span class="p">,</span> <span class="n">reg</span><span class="p">.</span><span class="n">Implementation</span><span class="p">,</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Transient</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although many other DI libraries contain an advanced API for doing convention based registration, we found that doing this with custom LINQ queries is easier to write, more understandable, and can often prove to be more flexible than using a predefined and restrictive API.</p>
<p>Another interesting scenario is registering multiple implementations of a generic interface. Say for instance your application contains the following interface:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">interface</span> <span class="n">IValidator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">ValidationResults</span> <span class="nf">Validate</span><span class="p">(</span><span class="n">T</span> <span class="n">instance</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Your application might contain many implementations of this interface for validating Customers, Employees, Products, Orders, etc. Without batch registration you would probably end up with a set registration similar to those we&#8217;ve already seen:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidator</span><span class="p">&lt;</span><span class="n">Customer</span><span class="p">&gt;,</span> <span class="n">CustomerValidator</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidator</span><span class="p">&lt;</span><span class="n">Employee</span><span class="p">&gt;,</span> <span class="n">EmployeeValidator</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidator</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;,</span> <span class="n">OrderValidator</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidator</span><span class="p">&lt;</span><span class="n">Product</span><span class="p">&gt;,</span> <span class="n">ProductValidator</span><span class="p">&gt;();</span>
<span class="c1">// and the list goes on...</span>
</pre></div>
</div>
<p>By using the extension methods for batch registration of open generic types from the <strong>SimpleInjector.Extensions</strong> namespace the same registrations can be made in a single line of code:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterManyForOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;).</span><span class="n">Assembly</span><span class="p">);</span>
</pre></div>
</div>
<p>By default <em>RegisterManyForOpenGeneric</em> searches the supplied assembly for all public types that implement the <strong>IValidator&lt;T&gt;</strong> interface and registers each type by their specific (closed generic) interface. It even works for types that implement multiple closed versions of the given interface.</p>
<div class="note container">
<strong>Note</strong>: There are numerous <em>RegisterManyForOpenGeneric</em> <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/Overload_SimpleInjector_Extensions_OpenGenericBatchRegistrationExtensions_RegisterManyForOpenGeneric.htm">overloads</a> available that take a list of <em>System.Type</em>&#8216;s, instead a list of <em>Assembly</em>&#8216;s.</div>
<p>Above are a couple of examples of the things you can do with batch registration. A more advanced scenario could be the registration of multiple implementations of the same closed generic type to a common interface, i.e. a set of types that all implement the same interface. There are so many possible variations of this scenario that <em>Simple Injector</em> does not contain an explicit method to handle this. What it does contain, however, are multiple overloads of the <em>RegisterManyForOpenGeneric</em> method that allow you to supply a callback delegate that enables you make the registrations yourself.</p>
<p>As an example, imagine the scenario where you have a <strong>CustomerValidator</strong> type and a <strong>GoldCustomerValidator</strong> type and they both implement <strong>IValidator&lt;Customer&gt;</strong> and you want to register them both at the same time. The earlier registration methods would throw an exception alerting you to the fact that you have multiple types implementing the same closed generic type. The following registration however, does enable this scenario:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterManyForOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;),</span>
    <span class="n">AccessibilityOption</span><span class="p">.</span><span class="n">PublicTypesOnly</span><span class="p">,</span>
    <span class="p">(</span><span class="n">serviceType</span><span class="p">,</span> <span class="n">implTypes</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">container</span><span class="p">.</span><span class="n">RegisterAll</span><span class="p">(</span><span class="n">serviceType</span><span class="p">,</span> <span class="n">implTypes</span><span class="p">),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;).</span><span class="n">Assembly</span><span class="p">);</span>
</pre></div>
</div>
<p>The code snippet registers all types from the given assembly that implement <strong>IValidator&lt;T&gt;</strong>. As we now have multiple implementations the container cannot inject a single instance of <strong>IValidator&lt;T&gt;</strong> and we can no longer call <em>container.GetInstance&lt;IValidator&lt;T&gt;&gt;()</em>. Instead instances can be retrieved by having an <strong>IEnumerable&lt;IValidator&lt;T&gt;&gt;</strong> constructor argument or by calling <em>container.GetAllInstances&lt;IValidator&lt;T&gt;&gt;()</em>.</p>
<p>It is not generally regarded as best practice to have an <strong>IEnumerable&lt;IValidator&lt;T&gt;&gt;</strong> dependency in multiple class constructors (or accessed from the  container directly). Depending on a set of types complicates your application design and can often be simplified with an alternate configuration. A better way is to have a single composite type that wraps <strong>IEnumerable&lt;IValidator&lt;T&gt;&gt;</strong> and presents it to the consumer as a single instance, in this case a <strong>CompositeValidator&lt;T&gt;</strong>:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">CompositeValidator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IValidator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IValidator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">validators</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">CompositeValidator</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IValidator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">validators</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">validators</span> <span class="p">=</span> <span class="n">validators</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">ValidationResults</span> <span class="nf">Validate</span><span class="p">(</span><span class="n">T</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">allResults</span> <span class="p">=</span> <span class="n">ValidationResults</span><span class="p">.</span><span class="n">Valid</span><span class="p">;</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">validator</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="n">validators</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="n">validator</span><span class="p">.</span><span class="n">Validate</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
            <span class="n">allResults</span> <span class="p">=</span> <span class="n">ValidationResults</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">allResults</span><span class="p">,</span> <span class="n">results</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">allResults</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This <strong>CompositeValidator&lt;T&gt;</strong> can be registered as follows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidate</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">CompositeValidator</span><span class="p">&lt;&gt;));</span>
</pre></div>
</div>
<p>This registration maps the open generic <strong>IValidator&lt;T&gt;</strong> interface to the open generic <strong>CompositeValidator&lt;T&gt;</strong> implementation. Because the <strong>CompositeValidator&lt;T&gt;</strong> contains an <strong>IEnumerable&lt;IValidator&lt;T&gt;&gt;</strong> dependency, the registered types will be injected into its constructor. This allows you to let the rest of the application simply depend on the <strong>IValidator&lt;T&gt;</strong>, while registering a collection of <strong>IValidator&lt;T&gt;</strong> implementations under the covers.</p>
<div class="note container">
<strong>Note</strong>: <em>Simple Injector</em> preserves the lifestyle of instances that are returned from an injected <strong>IEnumerable&lt;T&gt;</strong> instance. In reality you should not see the the injected <strong>IEnumerable&lt;IValidator&lt;T&gt;&gt;</strong> as a collection of implementations, you should consider it a <strong>stream</strong> of instances. Simple Injector will always inject a reference to the same stream (the <strong>IEnumerable&lt;T&gt;</strong> itself is a <em>Singleton</em>) and each time you iterate the <strong>IEnumerable&lt;T&gt;</strong>, for each individual component, the container is asked to resolve the instance based on the lifestyle of that component. Regardless of the fact that the <strong>CompositeValidator&lt;T&gt;</strong> is registered as singleton the validators it wraps will each have their own specific lifestyle.</div>
<p>The next section will explain mapping of open generic types (just like <strong>CompositeValidator&lt;&gt;</strong> seen above).</p>
</div>
<div class="section" id="id3">
<span id="registration-of-open-generic-types"></span><span id="id4"></span><h2>Registration of open generic types<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>When working with generic interfaces, we will often see numerous implementations of that interface being registered:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">Customer</span><span class="p">&gt;,</span> <span class="n">CustomerValidator</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">Employee</span><span class="p">&gt;,</span> <span class="n">EmployeeValidator</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;,</span> <span class="n">OrderValidator</span><span class="p">&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">Product</span><span class="p">&gt;,</span> <span class="n">ProductValidator</span><span class="p">&gt;();</span>
<span class="c1">// and the list goes on...</span>
</pre></div>
</div>
<p>As the previous section explained, this can be rewritten to the following one-liner:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterManyForOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidate</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">IValidate</span><span class="p">&lt;&gt;).</span><span class="n">Assembly</span><span class="p">);</span>
</pre></div>
</div>
<p>Sometimes you&#8217;ll find that many implementations of the given generic interface are no-ops or need the same standard implementation. The <strong>IValidate&lt;T&gt;</strong> is a good example, it is very likely that not all entities will need validation but your solution would like to treat all entities the same and not need to know whether any particular type has validation or not (having to write a specific empty validation for each type would be a horrible task). In a situation such as this we would ideally like to use the registration as described above, and have some way to fallback to some default implementation when no explicit registration exist for a given type. Such a default implementation could look like this:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// Implementation of the Null Object pattern.</span>
<span class="k">class</span> <span class="nc">NullValidator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IValidate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">ValidationResults</span> <span class="nf">Validate</span><span class="p">(</span><span class="n">T</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ValidationResults</span><span class="p">.</span><span class="n">Valid</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We could configure the container to use this <strong>NullValidator&lt;T&gt;</strong> for any entity that does not need validation:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">&gt;,</span> <span class="n">NullValidator</span><span class="p">&lt;</span><span class="n">OrderLine</span><span class="p">&gt;&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;,</span> <span class="n">NullValidator</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">UploadImage</span><span class="p">&gt;,</span> <span class="n">NullValidator</span><span class="p">&lt;</span><span class="n">UploadImage</span><span class="p">&gt;&gt;();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IValidate</span><span class="p">&lt;</span><span class="n">Mothership</span><span class="p">&gt;,</span> <span class="n">NullValidator</span><span class="p">&lt;</span><span class="n">Mothership</span><span class="p">&gt;&gt;();</span>
<span class="c1">// and the list goes on...</span>
</pre></div>
</div>
<p>This repeated registration is, of course, not very practical. Falling back to such a default implementation is a good example for <strong>unregistered type resolution</strong>. <em>Simple Injector</em> contains an event that you can hook into that allows you to fallback to a default implementation. The <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/Methods_T_SimpleInjector_Extensions_OpenGenericRegistrationExtensions.htm">RegisterOpenGeneric</a> extension method is defined to handle this registration. The <strong>NullValidator&lt;&gt;</strong> would be registered as follows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// using SimpleInjector.Extensions;</span>
<span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidate</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">NullValidator</span><span class="p">&lt;&gt;));</span>
</pre></div>
</div>
<p>The result of this registration is exactly as you would have expected to see from the individual registrations above. Each request for <strong>IValidate&lt;Department&gt;</strong>, for example, will return a single <strong>NullValidator&lt;Department&gt;</strong> instance each time.</p>
<div class="note container">
<strong>Note</strong>: Because the use of unregistered type resolution will only get called for types that are not explicitly registered this allows for the default implementation to be overridden with specific implementations. The <em>RegisterManyForOpenGeneric</em> method covered above does not use unregistered type resolution, it registers all the concrete types it finds in the given assemblies. Those types will therefore always be returned, giving a very convenient and easy to grasp mix.</div>
<p>There&#8217;s an advanced version of <em>RegisterOpenGeneric</em> overload that allows applying the open generic type conditionally, based on a supplied predicate. Example:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">LeftValidator</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">.</span><span class="n">GetGenericArguments</span><span class="p">().</span><span class="n">Single</span><span class="p">().</span><span class="n">Namespace</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">&quot;Left&quot;</span><span class="p">));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">RightValidator</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">.</span><span class="n">GetGenericArguments</span><span class="p">().</span><span class="n">Single</span><span class="p">().</span><span class="n">Namespace</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">&quot;Right&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p><em>Simple Injector</em> protects you from defining invalid registrations by ensuring that given the registrations do not overlap. Building on the last code snippet, imagine accidentally defining a type in the namespace &#8220;MyCompany.LeftRight&#8221;. In this case both open-generic implementations would apply, but <em>Simple Injector</em> will never silently pick one. It will throw an exception instead.</p>
<p>There are some instance where want to have a fallback implementation in the case that no other implementation was applied and this can be achieved by checking the <strong>Handled</strong> property of the predicate&#8217;s <strong>OpenGenericPredicateContext</strong> object:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ReadOnlyRepository</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IReadOnlyEntity</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">.</span><span class="n">GetGenericArguments</span><span class="p">().</span><span class="n">Single</span><span class="p">()));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ReadWriteRepository</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">c</span><span class="p">.</span><span class="n">Handled</span><span class="p">);</span>
</pre></div>
</div>
<p>In the case where the open generic implementation contains generic type constraints <em>Simple Injector</em> will automatically apply the type conditionally based on its generic type constraints:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ReadOnlyRepository</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IRepository</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IReadOnlyEntity</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ReadOnlyRepository</span><span class="p">&lt;&gt;));</span>
<span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IRepository</span><span class="p">&lt;&gt;),</span> <span class="k">typeof</span><span class="p">(</span><span class="n">ReadWriteRepository</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">c</span><span class="p">.</span><span class="n">Handled</span><span class="p">);</span>
</pre></div>
</div>
<p>The final option in <em>Simple Injector</em> is to supply the <em>RegisterOpenGeneric</em> method with a partially-closed generic type:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// SomeValidator&lt;List&lt;T&gt;&gt;</span>
<span class="kt">var</span> <span class="n">partiallyClosedType</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">SomeValidator</span><span class="p">&lt;&gt;).</span><span class="n">MakeGenericType</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;&gt;));</span>
<span class="n">container</span><span class="p">.</span><span class="n">RegisterOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IValidator</span><span class="p">&lt;&gt;),</span> <span class="n">partiallyClosedType</span><span class="p">);</span>
</pre></div>
</div>
<p>The type <strong>SomeValidator&lt;List&lt;T&gt;&gt;</strong> is called <strong>partially-closed</strong>, since although its generic type argument has been filled in with a type, it still contains a generic type argument. <em>Simple Injector</em> will be able to apply these constraints, just as it handles any other generic type constraints.</p>
</div>
<div class="section" id="id5">
<span id="unregistered-type-resolution"></span><span id="id6"></span><h2>Unregistered type resolution<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Unregistered type resolution is the ability to get notified by the container when a type that is currently unregistered in the container, is requested for the first time. This gives the user (or extension point) the change of registering that type. <em>Simple Injector</em> supports this scenario with the <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/E_SimpleInjector_Container_ResolveUnregisteredType.htm">ResolveUnregisteredType</a> event. Unregistered type resolution enables many advanced scenarios. The library itself uses this event for implementing the <a class="reference internal" href="#registration-of-open-generic-types"><em>registration of open generic types</em></a>. Other examples of possible scenarios that can be built on top of this event are <em class="xref std std-ref">resolving array and lists</em> and <a class="reference internal" href="#id18"><em>covariance and contravariance</em></a>. Those scenarios are described here in the advanced scenarios page.</p>
<p>For more information about how to use this event, please take a look at the <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/E_SimpleInjector_Container_ResolveUnregisteredType.htm">ResolveUnregisteredType event documentation</a> in the <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/">reference library</a>.</p>
</div>
<div class="section" id="id7">
<span id="contextual-binding"></span><span id="context-based-injection"></span><span id="id8"></span><h2>Context based injection<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Context based injection is the ability to inject a particular dependency based on the context it lives in (for change the implementation based on the type it is injected into). This context is often supplied by the container. Some DI libraries contain a feature that allows this, while others don’t. <em>Simple Injector</em> does <strong>not</strong> contain such a feature out of the box, but this ability can easily be added by using the [context based injection extension method|ContextDependentExtensions] code snippet.</p>
<div class="note container">
<strong>Note</strong>: In many cases context based injection is not the best solution, and the design should be reevaluated. In some narrow cases however it can make sense.</div>
<p>The most common scenario is to base the type of the injected dependency on the type of the consumer. Take for instance the following <strong>ILogger</strong> interface with a generic <strong>Logger&lt;T&gt;</strong> class that needs to be injected into several consumers.</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">interface</span> <span class="n">ILogger</span> <span class="p">{</span>
    <span class="k">void</span> <span class="nf">Log</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Logger</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ILogger</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Log</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Consumer1</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nf">Consumer1</span><span class="p">(</span><span class="n">ILogger</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Consumer2</span> <span class="p">{</span>
    <span class="k">public</span> <span class="nf">Consumer2</span><span class="p">(</span><span class="n">ILogger</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case we want to inject a <strong>Logger&lt;Consumer1&gt;</strong> into <strong>Consumer1</strong> and a <strong>Logger&lt;Consumer2&gt;</strong> into <strong>Consumer2</strong>. By using the previous [extension method|ContextDependentExtensions], we can accomplish this as follows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterWithContext</span><span class="p">&lt;</span><span class="n">ILogger</span><span class="p">&gt;(</span><span class="n">dependencyContext</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Logger</span><span class="p">&lt;&gt;).</span><span class="n">MakeGenericType</span><span class="p">(</span>
        <span class="n">dependencyContext</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">ILogger</span><span class="p">)</span><span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the previous code snippet we registered a <strong>Func&lt;DependencyContext, ILogger&gt;</strong> delegate, that will get called each time a <strong>ILogger</strong> dependency gets resolved. The <strong>DependencyContext</strong> instance that gets supplied to that instance, contains the <strong>ServiceType</strong> and <strong>ImplementationType</strong> into which the <strong>ILogger</strong> is getting injected.</p>
<div class="note container">
<strong>Note</strong>: Although building a generic type using MakeGenericType is relatively slow, the call to the <strong>Func&lt;DependencyContext, TService&gt;</strong> delegate itself is about as cheap as calling a <strong>Func&lt;TService&gt;</strong> delegate. If performance of the MakeGenericType gets a problem, you can always cache the generated types, cache <strong>InstanceProducer</strong> instances, or cache <strong>ILogger</strong> instances (note that caching the <strong>ILogger</strong> instances will make them singletons).</div>
<div class="note container">
<strong>Note</strong>: Even though the use of a generic <strong>Logger&lt;T&gt;</strong> is a common design (with log4net as the grand godfather of this design), doesn&#8217;t always make it a good design. The need for having the logger contain information about its parent type, might indicate design problems. If you&#8217;re doing this, please take a look at <a class="reference external" href="https://stackoverflow.com/a/9915056/264697">this Stackoverflow answer</a>. It talks about logging in conjunction with the SOLID design principles.</div>
</div>
<div class="section" id="generic-decorators">
<span id="decorators"></span><span id="id9"></span><h2>Decorators<a class="headerlink" href="#generic-decorators" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> principles give us important guidance when it comes to writing maintainable software. The &#8216;O&#8217; of the &#8216;SOLID&#8217; acronym stands for the <a class="reference external" href="https://en.wikipedia.org/wiki/Open/closed_principle">Open/closed Principle</a> which states that classes should be open for extension, but closed for modification. Designing systems around the Open/closed principle means that new behavior can be plugged into the system, without the need to change any existing parts, making the change of breaking existing code much smaller.</p>
<p>One of the ways to add new functionality (such as <a class="reference external" href="https://en.wikipedia.org/wiki/Cross-cutting_concern">cross-cutting concerns</a>) to classes is by the use of the <a class="reference external" href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>. The decorator pattern can be used to extend (decorate) the functionality of a certain object at run-time. Especially when using generic interfaces, the concept of decorators gets really powerful. Take for instance the examples given in the <a class="reference internal" href="#registration-of-open-generic-types"><em>Registration of open generic types</em></a> section of this page or for instance the use of an generic <strong>ICommandHandler&lt;TCommand&gt;</strong> interface.</p>
<div class="note container">
<strong>Tip</strong>: <a class="reference external" href="https://cuttingedge.it/blogs/steven/pivot/entry.php?id=91">This article</a> describes an architecture based on the use of the <strong>ICommandHandler&lt;TCommand&gt;</strong> interface.</div>
<p>Take the plausible scenario where we want to validate all commands that get executed by an <strong>ICommandHandler&lt;TCommand&gt;</strong> implementation. The Open/Closed principle states that we want to do this, without having to alter each and every implementation. We can do this using a (single) decorator:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">ValidationCommandHandlerDecorator</span><span class="p">&lt;</span><span class="n">TCommand</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">TCommand</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IValidator</span> <span class="n">validator</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">TCommand</span><span class="p">&gt;</span> <span class="n">handler</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">ValidationCommandHandlerDecorator</span><span class="p">(</span><span class="n">IValidator</span> <span class="n">validator</span><span class="p">,</span>
        <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">TCommand</span><span class="p">&gt;</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">validator</span> <span class="p">=</span> <span class="n">validator</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">handler</span> <span class="p">=</span> <span class="n">handler</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">TCommand</span><span class="p">&gt;.</span><span class="n">Handle</span><span class="p">(</span><span class="n">TCommand</span> <span class="n">command</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// validate the supplied command (throws when invalid).</span>
        <span class="k">this</span><span class="p">.</span><span class="n">validator</span><span class="p">.</span><span class="n">ValidateObject</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>

        <span class="c1">// forward the (valid) command to the real</span>
        <span class="c1">// command handler.</span>
        <span class="k">this</span><span class="p">.</span><span class="n">handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <strong>ValidationCommandHandlerDecorator&lt;TCommand&gt;</strong> class is an implementation of the <strong>ICommandHandler&lt;TCommand&gt;</strong> interface, but it also wraps / decorates an <strong>ICommandHandler&lt;TCommand&gt;</strong> instance. Instead of injecting the real implementation directly into a consumer, we can (let Simple Injector) inject a validator decorator that wraps the real implementation.</p>
<p>The <strong>ValidationCommandHandlerDecorator&lt;TCommand&gt;</strong> depends on an <strong>IValidator</strong> interface. An implementation that used Microsoft Data Annotations might look like this:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">using</span> <span class="nn">System.ComponentModel.DataAnnotations</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">DataAnnotationsValidator</span> <span class="p">:</span> <span class="n">IValidator</span> <span class="p">{</span>

    <span class="k">void</span> <span class="n">IValidator</span><span class="p">.</span><span class="n">ValidateObject</span><span class="p">(</span><span class="kt">object</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ValidationContext</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>

        <span class="c1">// Throws an exception when instance is invalid.</span>
        <span class="n">Validator</span><span class="p">.</span><span class="n">ValidateObject</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">validateAllProperties</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementations of the <strong>ICommandHandler&lt;T&gt;</strong> interface can be registered using the <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/Overload_SimpleInjector_Extensions_OpenGenericBatchRegistrationExtensions_RegisterManyForOpenGeneric.htm">RegisterManyForOpenGeneric</a> extension method:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterManyForOpenGeneric</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;).</span><span class="n">Assembly</span><span class="p">);</span>
</pre></div>
</div>
<p>By using the following extension method, you can wrap the <strong>ValidationCommandHandlerDecorator&lt;TCommand&gt;</strong> around each and every <strong>ICommandHandler&lt;TCommand&gt;</strong> implementation:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// using SimpleInjector.Extensions;</span>
<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ValidationCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>
</pre></div>
</div>
<p>Multiple decorators can be wrapped by calling the <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/Overload_SimpleInjector_Extensions_DecoratorExtensions_RegisterDecorator.htm">RegisterDecorator</a> method multiple times, as the following registration shows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterManyForOpenGeneric</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;).</span><span class="n">Assembly</span><span class="p">);</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">TransactionCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">DeadlockRetryCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ValidationCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>
</pre></div>
</div>
<p>The decorators are applied in the order in which they are registered, which means that the first decorator (<strong>TransactionCommandHandlerDecorator&lt;T&gt;</strong> in this case) wraps the real instance, the second decorator (<strong>DeadlockRetryCommandHandlerDecorator&lt;T&gt;</strong> in this case) wraps the first decorator, and so on.</p>
<p>There&#8217;s an overload of the <em>RegisterDecorator</em> available that allows you to supply a predicate to determine whether that decorator should be applied to a specific service type. Using a given context you can determine whether the decorator should be applied. Here is an example:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">AccessValidationCommandHandlerDecorator</span><span class="p">&lt;&gt;),</span>
    <span class="n">context</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">context</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">.</span><span class="n">Namespace</span><span class="p">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;Admins&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>The given context contains several properties that allows you to analyze whether a decorator should be applied to a given service type, such as the current closed generic service type (using the <strong>ServiceType</strong> property) and the concrete type that will be created (using the <strong>ImplementationType</strong> property). The predicate will (under normal circumstances) be called only once per generic type, so there is no performance penalty for using it.</p>
<div class="note container">
<strong>Tip</strong>: [This extension method|Runtime-Decorators] allows registering decorators that can be applied based on runtime conditions (such as the role of the current user).</div>
<div class="section" id="decorators-with-func-t-factories">
<span id="id10"></span><span id="decorators-with-func-factories"></span><h3>Decorators with Func&lt;T&gt; factories<a class="headerlink" href="#decorators-with-func-t-factories" title="Permalink to this headline">¶</a></h3>
<p>In certain scenarios, it is needed to postpone building part of the object graph. For instance when a service needs to control the lifetime of a dependency, needs multiple instances, when instances need to be [executed on a different thread|How-to#Multi_Threaded_Applications], or when instances need to be created in a certain [scope|ObjectLifestyleManagement#Scoped] or (security) context.</p>
<p>When building a &#8216;normal&#8217; object graph with dependencies, you can easily delay building a part of the graph by letting a service depend on a factory. This allows building that part of the object graph to be postponed until the time the type starts using the factory. When working with decorators however, injecting a factory to postpone the creation of the decorated instance will not work. Take for instance a <strong>AsyncCommandHandlerDecorator&lt;T&gt;</strong> that allows executing a command handler on a different thread. We could let the <strong>AsyncCommandHandlerDecorator&lt;T&gt;</strong> depend on a <strong>CommandHandlerFactory&lt;T&gt;</strong>, and let this factory call back into the container to retrieve a new <strong>ICommandHandler&lt;T&gt;</strong>. Unfortunately this would fail, since requesting an <strong>ICommandHandler&lt;T&gt;</strong> would again wrap this instance with a new <strong>AsyncCommandHandlerDecorator&lt;T&gt;</strong>, and we&#8217;d end up recursively creating the same instance and causing a stack overflow.</p>
<p>Since this is a scenario that is really hard to solve without library support, <em>Simple Injector</em> allows injecting a <strong>Func&lt;T&gt;</strong> delegate into registered decorators. This delegate functions as a factory for the creation of the decorated instance. Taking the <strong>AsyncCommandHandlerDecorator&lt;T&gt;</strong> as example, it could be implemented as follows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">AsyncCommandHandlerDecorator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">factory</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">AsyncCommandHandlerDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">factory</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">factory</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">T</span> <span class="n">command</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Execute on different thread.</span>
        <span class="n">ThreadPool</span><span class="p">.</span><span class="n">QueueUserWorkItem</span><span class="p">(**</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="c1">// Create new handler in this thread.</span>
            <span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">Invoke</span><span class="p">();</span>
            <span class="n">handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This special decorator can be registered just as any other decorator:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">AsyncCommandHandlerDecorator</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;Async&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>However, since the <strong>AsyncCommandHandlerDecorator&lt;T&gt;</strong> solely has singleton dependencies (the <strong>Func&lt;T&gt;</strong> is a singleton), and creates a new decorated instance each time it’s called, we can even register it as a singleton itself:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">AsyncCommandHandlerDecorator</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;Async&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>When mixing this with other (synchronous) decorators, you&#8217;ll get an extremely powerful and pluggable system:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterManyForOpenGeneric</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;).</span><span class="n">Assembly</span><span class="p">);</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">TransactionCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">DeadlockRetryCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">AsyncCommandHandlerDecorator</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;Async&quot;</span><span class="p">));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ICommandHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ValidationCommandHandlerDecorator</span><span class="p">&lt;&gt;));</span>
</pre></div>
</div>
<p>This configuration has an interesting mix of decorator registrations. The registration of the <strong>AsyncCommandHandlerDecorator&lt;T&gt;</strong> allows (some of) the command handlers to be executed on the background (while others -who&#8217;s name does not start with &#8216;Async&#8217;- still run synchronously), but before execution, all commands are validated synchronously (to allow communicating validation errors to the caller). And all handlers (even the asynchronous ones) are executed in a transaction and the operation is retried when the database rolled back because of a deadlock).</p>
</div>
<div class="section" id="id11">
<span id="decorated-collections"></span><span id="id12"></span><h3>Decorated collections<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>When registering a decorator, <em>Simple Injector</em> will automatically decorate any collection with elements of that service type:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterAll</span><span class="p">&lt;</span><span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">CustomerMovedEvent</span><span class="p">&gt;&gt;(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">CustomerMovedEventHandler</span><span class="p">),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">NotifyStaffWhenCustomerMovedEventHandler</span><span class="p">));</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">IEventHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ValidationEventHandlerDecorator</span><span class="p">&lt;&gt;),</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="n">SomeCondition</span><span class="p">);</span>
</pre></div>
</div>
<p>The previous registration registers a collection of <strong>IEventHandler&lt;CustomerMovedEvent&gt;</strong> services. Those services are decorated with a <strong>ValidationEventHandlerDecorator&lt;TEvent&gt;</strong> when the supplied predicate holds.</p>
<p>For collections of elements that are created by the container (container controlled), the predicate is checked for each element in the collection. For collections of uncontrolled elements (a list of items that is not created by the container), the predicate is checked once for the whole collection. This means that controlled collections can be partially decorated. Taking the previous example for instance, you could let the <strong>CustomerMovedEventHandler</strong> be decorated, while leaving the <strong>NotifyStaffWhenCustomerMovedEventHandler</strong> undecorated (determined by the supplied predicate).</p>
<p>When a collection is uncontrolled, it means that the lifetime of its elements are unknown to the container. The following registration is an example of an uncontrolled collection:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">CustomerMovedEvent</span><span class="p">&gt;&gt;</span> <span class="n">handlers</span> <span class="p">=</span>
    <span class="k">new</span> <span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">CustomerMovedEvent</span><span class="p">&gt;[]</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="nf">CustomerMovedEventHandler</span><span class="p">(),</span>
        <span class="k">new</span> <span class="nf">NotifyStaffWhenCustomerMovedEventHandler</span><span class="p">(),</span>
    <span class="p">};</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterAll</span><span class="p">&lt;</span><span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">CustomerMovedEvent</span><span class="p">&gt;&gt;(</span><span class="n">handlers</span><span class="p">);</span>
</pre></div>
</div>
<p>Although this registration contains a list of singletons, the container has no way of knowing this. The collection could easily have been a dynamic (an ever changing) collection. In this case, the container calls the registered predicate once (and supplies the predicate with the <strong>IEventHandler&lt;CusotmerMovedEvent&gt;</strong> type) and if the predicate returns true, each element in the collection is decorated with a decorator instance.</p>
<div class="note container">
<strong>Warning</strong>: In general you should prevent registering uncontrolled collections. The container knows nothing about them, and can&#8217;t help you in doing [diagnostics|Diagnostics]. Since the lifetime of those items is unknown, the container will be unable to wrap a decorator with a lifestyle other than transient. Best practice is to register container-controlled collections which is done by using one of the <em>RegisterAll</em> overloads that take a collection of <em>System.Type</em> instances.</div>
</div>
<div class="section" id="decorator-registration-factories">
<span id="id13"></span><h3>Decorator registration factories<a class="headerlink" href="#decorator-registration-factories" title="Permalink to this headline">¶</a></h3>
<p>In some advanced scenarios, it can be useful to depend the actual decorator type based on some contextual information. <em>Simple Injector</em> contains a <em>RegisterDecorator</em> overload that accepts a factory delegate that allows building the exact decorator type based on the actual type being decorated.</p>
<p>Take the following registration for instance:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterDecorator</span><span class="p">(</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">IEventHandler</span><span class="p">&lt;&gt;),</span>
    <span class="n">factoryContext</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">LoggingEventHandlerDecorator</span><span class="p">&lt;,&gt;).</span><span class="n">MakeGenericType</span><span class="p">(</span>
        <span class="k">typeof</span><span class="p">(</span><span class="n">LoggingEventHandler</span><span class="p">&lt;,&gt;).</span><span class="n">GetGenericArguments</span><span class="p">().</span><span class="n">First</span><span class="p">(),</span>
        <span class="n">factoryContext</span><span class="p">.</span><span class="n">ImplementationType</span><span class="p">),</span>
    <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Transient</span><span class="p">,</span>
    <span class="n">predicateContext</span> <span class="p">=&gt;</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p>This example registers a decorator for the <strong>IEventHandler&lt;TEvent&gt;</strong> abstraction. The decorator to be used is the <strong>LoggingEventHandlerDecorator&lt;TEvent, TLogTarget&gt;</strong> type. The supplied factory delegate builds up a partially-closed open-generic type by filling in the <strong>TLogTarget</strong> argument with the actual wrapped event handler implementation type. Simple Injector will fill in the generic type argument <strong>TEvent</strong>.</p>
</div>
</div>
<div class="section" id="interception">
<span id="id14"></span><h2>Interception<a class="headerlink" href="#interception" title="Permalink to this headline">¶</a></h2>
<p>Interception is the ability to intercept a call from a consumer to a service, and add or change behavior. The <a class="reference external" href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a> describes a form of interception, but when it comes to applying cross-cutting concerns, you might end up writing decorators for many service interfaces, but with the exact same code. If this is happening, it is time to explore the possibilities of interception.</p>
<p>Using the [Interception extensions|InterceptionExtensions] code snippets, you can add the ability to do interception with <em>Simple Injector</em>. Using the given code, you can for instance define a <strong>MonitoringInterceptor</strong> that allows logging the execution time of the called service method:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">private</span> <span class="k">class</span> <span class="nc">MonitoringInterceptor</span> <span class="p">:</span> <span class="n">IInterceptor</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ILogger</span> <span class="n">logger</span><span class="p">;</span>

    <span class="c1">// Using constructor injection on the interceptor</span>
    <span class="k">public</span> <span class="nf">MonitoringInterceptor</span><span class="p">(</span><span class="n">ILogger</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Intercept</span><span class="p">(</span><span class="n">IInvocation</span> <span class="n">invocation</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">watch</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="n">StartNew</span><span class="p">();</span>

        <span class="c1">// Calls the decorated instance.</span>
        <span class="n">invocation</span><span class="p">.</span><span class="n">Proceed</span><span class="p">();</span>

        <span class="kt">var</span> <span class="n">decoratedType</span> <span class="p">=</span>
            <span class="n">invocation</span><span class="p">.</span><span class="n">InvocationTarget</span><span class="p">.</span><span class="n">GetType</span><span class="p">();</span>

        <span class="k">this</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">Log</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span>
            <span class="s">&quot;{0} executed in {1} ms.&quot;</span><span class="p">,</span>
            <span class="n">decoratedType</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
            <span class="n">watch</span><span class="p">.</span><span class="n">ElapsedMiliseconds</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This interceptor can be registered to be wrapped around a concrete implementation. Using the given extension methods, this can be done as follows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">InterceptWith</span><span class="p">&lt;</span><span class="n">MonitoringInterceptor</span><span class="p">&gt;(</span><span class="n">type</span> <span class="p">=&gt;</span> <span class="n">type</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">IUserRepository</span><span class="p">));</span>
</pre></div>
</div>
<p>This registration ensures that every time an <strong>IUserRepository</strong> interface is requested, an interception proxy is returned that wraps that instance and uses the <strong>MonitoringInterceptor</strong> to extend the behavior.</p>
<p>The current example doesn&#8217;t add much compared to simply using a decorator. When having many interface service types that need to be decorated with the same behavior however, it gets different:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">InterceptWith</span><span class="p">&lt;</span><span class="n">MonitoringInterceptor</span><span class="p">&gt;(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;Repository&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="note container">
<strong>Note</strong>: The [Interception extensions|InterceptionExtensions] code snippets use .NET&#8217;s <strong>System.Runtime.Remoting.Proxies.RealProxy</strong> class to generate interception proxies. The <strong>RealProxy</strong> only allows to proxy interfaces.</div>
<div class="note container">
<strong>Note</strong>: the interfaces in the given [Interception extensions|InterceptionExtensions] code snippets are a simplified version of the Castle Project interception facility. If you need to create lots different interceptors, you might benefit from using the interception abilities of the Castle Project. Also please note that the given snippets use dynamic proxies to do the interception, while Castle uses lightweight code generation (LCG). LCG allows much better performance than the use of dynamic proxies.</div>
<div class="note container">
<strong>Note</strong>: Don&#8217;t use interception for intercepting types that all implement the same generic interface, such as <strong>ICommandHandler&lt;T&gt;</strong> or <strong>IValidator&lt;T&gt;</strong>. Try using decorator classes instead, as shown in the <a class="reference internal" href="#decorators"><em>Decorators</em></a> section on this page.</div>
</div>
<div class="section" id="property-injection">
<span id="id16"></span><span id="implicit-property-injection"></span><span id="id17"></span><h2>Property injection<a class="headerlink" href="#property-injection" title="Permalink to this headline">¶</a></h2>
<p>Simple Injector does not inject any properties into types that get resolved by the container. In general there are two ways of doing property injection, and both are not enabled by default for reasons explained below.</p>
<p><em>Implicit property injection</em>
Some containers (such as Castle Windsor) implicitly inject public writable properties by default for any instance you resolve. They do this by mapping those properties to configured types. When no such registration exists, or when the property doesn’t have a public setter, the property will be skipped. Simple Injector does not do implicit property injection, and for good reason. We think that <strong>implicit property injection</strong> is simply too uuhh...  implicit :-). Silently skipping properties that can&#8217;t be mapped can lead to a DI configuration that can&#8217;t be easily verified and can therefore result in an application that fails at runtime instead of failing when the container is verified.</p>
<p><em>Explicit property injection</em>
We strongly feel that explicit property injection is a much better way to go. With explicit property injection the container is forced to inject a property and the process will fail immediately when a property can&#8217;t be mapped or injected. Some containers (such as Unity and Ninject) allow explicit property injection by allowing properties to be decorated with attributes that are defined by the DI library. Problem with this is that this forces the application to take a dependency on the library, which is something that should be prevented.</p>
<p>Because <em>Simple Injector</em> does not encourage its users to take a dependency on the container (except for the startup path of course), <em>Simple Injector</em> does not contain any attributes that allow explicit property injection and it can therefore not explicitly inject properties out-of-the-box.</p>
<p>Besides this, the use of property injection should be very exceptional and in general constructor injection should be used in the majority of cases. If a constructor gets too many parameters (constructor over-injection anti-pattern), it is an indication of a violation of the <a class="reference external" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> (SRP). SRP violations often lead to maintainability issues. So instead of patching constructor over-injection with property injection, the root cause should be analyzed and the type should be refactored, probably with <a class="reference external" href="http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/">Facade Services</a>. Another common reason to use properties is because those dependencies are optional. Instead of using optional property dependencies, best practice is to inject empty implementations (a.k.a. <a class="reference external" href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object pattern</a>) into the constructor.</p>
<p><em>Enabling property injection</em>
<em>Simple Injector</em> contains two ways to enable property injection. First of all the <a class="reference internal" href="using.html#configuring-property-injection"><em>RegisterInitializer&lt;T&gt;</em></a> method can be used to inject properties (especially configuration values) on a per-type basis. Take for instance the following code snippet:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterInitializer</span><span class="p">&lt;</span><span class="n">HandlerBase</span><span class="p">&gt;(</span><span class="n">handlerToInitialize</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">handlerToInitialize</span><span class="p">.</span><span class="n">ExecuteAsynchronously</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the previous example an <strong>Action&lt;T&gt;</strong> delegate is registered that will be called every time the container creates a type that inherits from <strong>HandlerBase</strong>. In this case, the handler will set a configuration value on that class.</p>
<div class="note container">
<strong>Note</strong>: although this method can also be used injecting services, please note that the [Diagnostic Services|Diagnostics] will be unable to see and analyze that dependency.</div>
<p id="importpropertyselectionbehavior">The second way to inject properties is by implementing a custom <em>IPropertySelectionBehavior</em>. The <strong>property selection behavior</strong> is a general extension point provided by the container, to override the library&#8217;s default behavior (which is to <strong>not</strong> inject properties). The following example enables explicit property injection using attributes, using the <strong>ImportAttribute</strong> from the <strong>System.ComponentModel.Composition.dll</strong>:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.ComponentModel.Composition</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">SimpleInjector.Advanced</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ImportPropertySelectionBehavior</span> <span class="p">:</span> <span class="n">IPropertySelectionBehavior</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">SelectProperty</span><span class="p">(</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="n">PropertyInfo</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">prop</span><span class="p">.</span><span class="n">GetCustomAttributes</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ImportAttribute</span><span class="p">)).</span><span class="n">Any</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The previous class can be registered as follows:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">PropertySelectionBehavior</span> <span class="p">=</span>
    <span class="k">new</span> <span class="nf">ImportPropertySelectionBehavior</span><span class="p">();</span>
</pre></div>
</div>
<p>This enables explicit property injection on all properties that are marked with the [Import] attribute and an exception will be thrown when the property cannot be injected for whatever reason.</p>
<div class="note container">
<strong>Tip</strong>: Properties injected by the container through the <strong>IPropertySelectionBehavior</strong> will be analyzed by the [Diagnostic Services|Diagnostics].</div>
<div class="note container">
<strong>Note</strong>: The <strong>IPropertySelectionBehavior</strong> extension mechanism can also be used to implement implicit property injection. There&#8217;s <a class="reference external" href="https://simpleinjector.codeplex.com/SourceControl/latest#SimpleInjector.CodeSamples/ImplicitPropertyInjectionExtensions.cs">an example of this</a> in the source code. Doing so however is not advised because of the reasons given above.</div>
</div>
<div class="section" id="covariance-and-contravariance">
<span id="id18"></span><span id="covariance-contravariance"></span><h2>Covariance and Contravariance<a class="headerlink" href="#covariance-and-contravariance" title="Permalink to this headline">¶</a></h2>
<p>Since version 4.0 of the .NET framework, the type system allows <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dd799517.aspx">Covariance and Contravariance in Generics</a> (especially interfaces and delegates). This allows for instance, to use a <strong>IEnumerable&lt;string&gt;</strong> as an <strong>IEnumerable&lt;object&gt;</strong> (covariance), or to use an <strong>Action&lt;object&gt;</strong> as an <strong>Action&lt;string&gt;</strong> (contravariance).</p>
<p>In some circumstances, the application design can benefit from the use of covariance and contravariance (or variance for short) and it would be beneficial when the IoC container returns services that are &#8216;compatible&#8217; to the requested service, even although the requested service is not registered. To stick with the previous example, the container could return an <strong>IEnumerable&lt;string&gt;</strong> even when an <strong>IEnumerable&lt;object&gt;</strong> is requested.</p>
<p>By default, <em>Simple Injector</em> does not return variant implementations of given services, but Simple Injector can be extended to behave this way. The actual way to write this extension depends on the requirements of the application.</p>
<p>Take a look at the following application design around the <strong>IEventHandler&lt;in TEvent&gt;</strong> interface:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">interface</span> <span class="n">IEventHandler</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">TEvent</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">void</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">TEvent</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerMovedEvent</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">CustomerId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Address</span> <span class="n">NewAddress</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerMovedAbroadEvent</span> <span class="p">:</span> <span class="n">CustomerMovedEvent</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">Country</span> <span class="n">Country</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CustomerMovedEventHandler</span> <span class="p">:</span> <span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">CustomerMovedEvent</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">CustomerMovedEvent</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The design contains two event classes <strong>CustomerMovedEvent</strong> and <strong>CustomerMovedAbroadEvent</strong> (where <strong>CustomerMovedAbroadEvent</strong> inherits from <strong>CustomerMovedEvent</strong>) one concrete event handler <strong>CustomerMovedEventHandler</strong> and a generic interface for event handlers.</p>
<p>We can configure the container in such way that not only a request for <strong>IEventHandler&lt;CustomerMovedEvent&gt;</strong> results in a <strong>CustomerMovedEventHandler,</strong> but also a request for <strong>IEventHandler&lt;CustomerMovedAbroadEvent&gt;</strong> results in that same <strong>CustomerMovedEventHandler</strong> (because <strong>CustomerMovedEventHandler</strong> also accepts <strong>CustomerMovedAbroadEvents</strong>).</p>
<p>There are multiple ways to achieve this. Here&#8217;s one:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">CustomerMovedEventHandler</span><span class="p">&gt;();</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleOpenGeneric</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">IEventHandler</span><span class="p">&lt;&gt;),</span>
    <span class="k">typeof</span><span class="p">(</span><span class="n">ContravarianceEventHandler</span><span class="p">&lt;&gt;));</span>
</pre></div>
</div>
<p>This registration depends on the custom <strong>ContravarianceEventHandler&lt;TEvent&gt;</strong> that should be placed close to the registration itself:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">ContravarianceEventHandler</span><span class="p">&lt;</span><span class="n">TEvent</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">TEvent</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">private</span> <span class="n">Registration</span> <span class="n">registration</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">ContravarianceEventHandler</span><span class="p">(</span><span class="n">Container</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// NOTE: GetCurrentRegistrations has a perf characteristic of O(n), so</span>
        <span class="c1">// make sure this type is registered as singleton.</span>
        <span class="n">registration</span> <span class="p">=</span> <span class="p">(</span>
            <span class="k">from</span> <span class="n">reg</span> <span class="k">in</span> <span class="n">container</span><span class="p">.</span><span class="n">GetCurrentRegistrations</span><span class="p">()</span>
            <span class="k">where</span> <span class="nf">typeof</span><span class="p">(</span><span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">TEvent</span><span class="p">&gt;).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">ServiceType</span><span class="p">)</span>
            <span class="k">select</span> <span class="n">reg</span><span class="p">)</span>
            <span class="p">.</span><span class="n">Single</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">TEvent</span><span class="p">&gt;.</span><span class="n">Handle</span><span class="p">(</span><span class="n">TEvent</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="p">(</span><span class="n">IEventHandler</span><span class="p">&lt;</span><span class="n">TEvent</span><span class="p">&gt;)</span><span class="k">this</span><span class="p">.</span><span class="n">registration</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">();</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The registration ensures that every time an <strong>IEventHandler&lt;TEvent&gt;</strong> is requested, a <strong>ContravarianceEventHandler&lt;TEvent&gt;</strong> is returned. The <strong>ContravarianceEventHandler&lt;TEvent&gt;</strong> will on creation query the container for a single service type that implements the specified <strong>IEventHandler&lt;TEvent&gt;</strong>. Because the <strong>CustomerMovedEventHandler</strong> is the only registered event handler for <strong>IEventHandler&lt;CustomerMovedEvent&gt;</strong>, the <strong>ContravarianceEventHandler&lt;CustomerMovedEvent&gt;</strong> will find that type and call it.</p>
<p>This is just one example and one way of adding variance support. For a more elaborate discussion on this subject, please read the following article: <a class="reference external" href="https://cuttingedge.it/blogs/steven/pivot/entry.php?id=90">Adding Covariance and Contravariance to Simple Injector</a>.</p>
</div>
<div class="section" id="registering-plugins-dynamically">
<span id="plugins"></span><h2>Registering plugins dynamically<a class="headerlink" href="#registering-plugins-dynamically" title="Permalink to this headline">¶</a></h2>
<p>Applications with a plugin architecture often allow special plugin assemblies to be dropped in a special folder and to be picked up by the application, without the need of a recompile. Although <em>Simple Injector</em> has no out of the box support for this, registering plugins from dynamically loaded assemblies can be implemented in a few lines of code. Here is an example:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">string</span> <span class="n">pluginDirectory</span> <span class="p">=</span>
    <span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="n">BaseDirectory</span><span class="p">,</span> <span class="s">&quot;Plugins&quot;</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">pluginAssemblies</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">file</span> <span class="k">in</span> <span class="k">new</span> <span class="nf">DirectoryInfo</span><span class="p">(</span><span class="n">pluginDirectory</span><span class="p">).</span><span class="n">GetFiles</span><span class="p">()</span>
    <span class="k">where</span> <span class="n">file</span><span class="p">.</span><span class="n">Extension</span><span class="p">.</span><span class="n">ToLower</span><span class="p">()</span> <span class="p">==</span> <span class="s">&quot;.dll&quot;</span>
    <span class="k">select</span> <span class="n">Assembly</span><span class="p">.</span><span class="n">LoadFile</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">FullName</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">pluginTypes</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">assembly</span> <span class="k">in</span> <span class="n">pluginAssemblies</span>
    <span class="k">from</span> <span class="n">type</span> <span class="k">in</span> <span class="n">assembly</span><span class="p">.</span><span class="n">GetExportedTypes</span><span class="p">()</span>
    <span class="k">where</span> <span class="nf">typeof</span><span class="p">(</span><span class="n">IPlugin</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
    <span class="k">where</span> <span class="p">!</span><span class="n">type</span><span class="p">.</span><span class="n">IsAbstract</span>
    <span class="k">where</span> <span class="p">!</span><span class="n">type</span><span class="p">.</span><span class="n">IsGenericTypeDefinition</span>
    <span class="k">select</span> <span class="n">type</span><span class="p">;</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterAll</span><span class="p">&lt;</span><span class="n">IPlugin</span><span class="p">&gt;(</span><span class="n">pluginTypes</span><span class="p">);</span>
</pre></div>
</div>
<p>The given example makes use of an <strong>IPlugin</strong> interface that is known to the application, and probably located in a shared assembly. The dynamically loaded plugin .dll files can contain multiple classes that implement <strong>IPlugin</strong>, and all publicly exposed concrete types that implements <strong>IPlugin</strong> will be registered using the <strong>RegisterAll</strong> method and can get resolved using the default auto-wiring behavior of the container, meaning that the plugin must have a single public constructor and all constructor arguments must be resolvable by the container. The plugins can get resolved using <strong>container.GetAllInstances&lt;IPlugin&gt;()</strong> or by adding an <strong>IEnumerable&lt;IPlugin&gt;</strong> argument to a constructor.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advanced Scenarios</a><ul>
<li><a class="reference internal" href="#generics">Generics</a></li>
<li><a class="reference internal" href="#batch-automatic-registration">Batch / Automatic registration</a></li>
<li><a class="reference internal" href="#id3">Registration of open generic types</a></li>
<li><a class="reference internal" href="#id5">Unregistered type resolution</a></li>
<li><a class="reference internal" href="#id7">Context based injection</a></li>
<li><a class="reference internal" href="#generic-decorators">Decorators</a><ul>
<li><a class="reference internal" href="#decorators-with-func-t-factories">Decorators with Func&lt;T&gt; factories</a></li>
<li><a class="reference internal" href="#id11">Decorated collections</a></li>
<li><a class="reference internal" href="#decorator-registration-factories">Decorator registration factories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interception">Interception</a></li>
<li><a class="reference internal" href="#property-injection">Property injection</a></li>
<li><a class="reference internal" href="#covariance-and-contravariance">Covariance and Contravariance</a></li>
<li><a class="reference internal" href="#registering-plugins-dynamically">Registering plugins dynamically</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="using.html"
                        title="previous chapter">Using Simple Injector</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/advanced.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="using.html" title="Using Simple Injector"
             >previous</a> |</li>
        <li><a href="index.html">Simple Injector 2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Simple Injector Contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>