

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Object Lifetime Management &mdash; Simple Injector 2 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Simple Injector 2 documentation" href="index.html"/>
        <link rel="next" title="Integration Guide" href="integration.html"/>
        <link rel="prev" title="Using Simple Injector" href="using.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> Simple Injector</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#a-quick-example">A Quick Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="quickstart.html#more-information">More information</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using Simple Injector</a><ul>
<li class="toctree-l2"><a class="reference internal" href="using.html#resolving-instances">Resolving instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="using.html#configuring-simple-injector">Configuring Simple Injector</a></li>
<li class="toctree-l2"><a class="reference internal" href="using.html#collections">Collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="using.html#verifying-the-container-s-configuration">Verifying the container&#8217;s configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="using.html#automatic-constructor-injection-auto-wiring">Automatic constructor injection / auto-wiring</a></li>
<li class="toctree-l2"><a class="reference internal" href="using.html#more-information">More information</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Object Lifetime Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#transient">Transient</a></li>
<li class="toctree-l2"><a class="reference internal" href="#singleton">Singleton</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scoped">Scoped</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-web-request">Per Web Request</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-web-api-request">Per Web API Request</a></li>
<li class="toctree-l2"><a class="reference internal" href="#web-api-request-lifestyle-vs-web-request-lifestyle">Web API Request lifestyle vs. Web Request lifestyle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-wcf-operation">Per WCF Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-lifetime-scope">Per Lifetime Scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-execution-context-scope-async-await">Per Execution Context Scope (async/await)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-graph">Per Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instance-per-dependency">Instance Per Dependency</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-thread">Per Thread</a></li>
<li class="toctree-l2"><a class="reference internal" href="#per-http-session">Per HTTP Session</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hybrid">Hybrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="#developing-a-custom-lifestyle">Developing a Custom Lifestyle</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Integration Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="aspnetintegration.html">ASP.NET Core (beta!)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvcintegration.html">ASP.NET MVC</a></li>
<li class="toctree-l2"><a class="reference internal" href="webapiintegration.html">ASP.NET Web API</a></li>
<li class="toctree-l2"><a class="reference internal" href="webformsintegration.html">ASP.NET Web Forms</a></li>
<li class="toctree-l2"><a class="reference internal" href="owinintegration.html">OWIN</a></li>
<li class="toctree-l2"><a class="reference internal" href="windowsformsintegration.html">Windows Forms</a></li>
<li class="toctree-l2"><a class="reference internal" href="wcfintegration.html">WCF</a></li>
<li class="toctree-l2"><a class="reference internal" href="wpfintegration.html">WPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="silverlightintegration.html">Silverlight</a></li>
<li class="toctree-l2"><a class="reference internal" href="integration.html#patterns">Patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics.html">Diagnostic Services</a><ul>
<li class="toctree-l2"><a class="reference internal" href="diagnostics.html#how-to-view-diagnostic-results">How to view diagnostic results</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics.html#suppressing-warnings">Suppressing warnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics.html#limitations">Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics.html#supported-warnings">Supported Warnings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="howto.html">How To</a><ul>
<li class="toctree-l2"><a class="reference internal" href="howto.html#register-factory-delegates">Register factory delegates</a></li>
<li class="toctree-l2"><a class="reference internal" href="howto.html#resolve-instances-by-key">Resolve instances by key</a></li>
<li class="toctree-l2"><a class="reference internal" href="howto.html#register-multiple-interfaces-with-the-same-implementation">Register multiple interfaces with the same implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="howto.html#override-existing-registrations">Override existing registrations</a></li>
<li class="toctree-l2"><a class="reference internal" href="howto.html#verify-the-container-s-configuration">Verify the container&#8217;s configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="howto.html#work-with-dependency-injection-in-multi-threaded-applications">Work with dependency injection in multi-threaded applications</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Scenarios</a><ul>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#generics">Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#batch-automatic-registration">Batch / Automatic registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#registration-of-open-generic-types">Registration of open generic types</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#mixing-collections-of-open-generic-and-non-generic-components">Mixing collections of open-generic and non-generic components</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#unregistered-type-resolution">Unregistered type resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#context-based-injection">Context based injection</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#decorators">Decorators</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#interception">Interception</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#property-injection">Property injection</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#covariance-and-contravariance">Covariance and Contravariance</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html#registering-plugins-dynamically">Registering plugins dynamically</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extensibility.html">Extensibility Points</a><ul>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#overriding-constructor-resolution-behavior">Overriding Constructor Resolution Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#overriding-property-injection-behavior">Overriding Property Injection Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#overriding-parameter-injection-behavior">Overriding Parameter Injection Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#resolving-unregistered-types">Resolving Unregistered Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#overriding-lifestyle-selection-behavior">Overriding Lifestyle Selection Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#intercepting-the-creation-of-types">Intercepting the Creation of Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#building-up-external-instances">Building up External Instances</a></li>
<li class="toctree-l2"><a class="reference internal" href="extensibility.html#interception-of-resolved-object-graphs">Interception of Resolved Object Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pipeline.html">Simple Injector Pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pipeline.html#registration-pipeline">Registration Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="pipeline.html#resolve-pipeline">Resolve Pipeline</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="principles.html">Design Principles</a><ul>
<li class="toctree-l2"><a class="reference internal" href="principles.html#make-simple-use-cases-easy-make-complex-use-cases-possible">Make simple use cases easy, make complex use cases possible</a></li>
<li class="toctree-l2"><a class="reference internal" href="principles.html#push-developers-into-best-practices">Push developers into best practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="principles.html#fast-by-default">Fast by default</a></li>
<li class="toctree-l2"><a class="reference internal" href="principles.html#don-t-force-vendor-lock-in">Don&#8217;t force vendor lock-in</a></li>
<li class="toctree-l2"><a class="reference internal" href="principles.html#never-fail-silently">Never fail silently</a></li>
<li class="toctree-l2"><a class="reference internal" href="principles.html#features-should-be-intuitive">Features should be intuitive</a></li>
<li class="toctree-l2"><a class="reference internal" href="principles.html#communicate-errors-clearly-and-describe-how-to-solve-them">Communicate errors clearly and describe how to solve them</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="decisions.html">Design Decisions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#the-container-is-locked-after-the-first-call-to-resolve">The container is locked after the first call to resolve</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#the-api-clearly-differentiates-the-registration-of-collections">The API clearly differentiates the registration of collections</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#no-support-for-xml-based-configuration">No support for XML based configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#never-force-users-to-release-what-they-resolve">Never force users to release what they resolve</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#don-t-allow-resolving-scoped-instances-outside-an-active-scope">Don&#8217;t allow resolving scoped instances outside an active scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#no-out-of-the-box-support-for-property-injection">No out-of-the-box support for property injection</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#no-out-of-the-box-support-for-interception">No out-of-the-box support for interception</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#limited-batch-registration-api">Limited batch-registration API</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#no-per-thread-lifestyle">No per-thread lifestyle</a></li>
<li class="toctree-l2"><a class="reference internal" href="decisions.html#allow-only-a-single-constructor">Allow only a single constructor</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="legal.html">Legal stuff</a><ul>
<li class="toctree-l2"><a class="reference internal" href="legal.html#simple-injector-license">Simple Injector License</a></li>
<li class="toctree-l2"><a class="reference internal" href="legal.html#contributions">Contributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="legal.html#simple-injector-trademark-policy">Simple Injector Trademark Policy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contribute.html">How to Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Appendix</a><ul>
<li class="toctree-l2"><a class="reference internal" href="InterceptionExtensions.html">Interception Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="varianceextensions.html">Variance Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="t4mvc.html">T4MVC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/">API Documentation</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Simple Injector</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Object Lifetime Management</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/lifetimes.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="object-lifetime-management">
<h1>Object Lifetime Management<a class="headerlink" href="#object-lifetime-management" title="Permalink to this headline">¶</a></h1>
<p>Object Lifetime Management is the concept of controlling the number of instances a configured service will have and the duration of the lifetime of those instances. In other words, it allows you to determine how returned instances are cached. Most DI libraries have sophisticated mechanisms for lifestyle management, and Simple Injector is no exception with built-in support for the most common lifestyles. The three default lifestyles (transient, scoped and singleton) are part of the core library. Implementations for the scoped lifestyle can be found within some of the extension and integration packages. The built-in lifestyles will suit about 99% of cases. For anything else custom lifestyles can be used.</p>
<p>Below is a list of the most common lifestyles with code examples of how to configure them using Simple Injector:</p>
<ul class="simple">
<li><a class="reference internal" href="#transient"><em>Transient</em></a></li>
<li><a class="reference internal" href="#scoped"><em>Scoped</em></a></li>
<li><a class="reference internal" href="#singleton"><em>Singleton</em></a></li>
</ul>
<p>Many different platform and framework specific flavors are available for the <em>Scoped</em> lifestyle, namely:</p>
<ul class="simple">
<li><a class="reference internal" href="#perwebrequest"><em>Per Web Request</em></a></li>
<li><a class="reference internal" href="#perwebapirequest"><em>Per Web API Request</em></a></li>
<li><a class="reference internal" href="#perwcfoperation"><em>Per WCF Operation</em></a></li>
<li><a class="reference internal" href="#perlifetimescope"><em>Per Lifetime Scope</em></a></li>
<li><a class="reference internal" href="#perexecutioncontextscope"><em>Per Execution Context Scope (async/await)</em></a></li>
</ul>
<p>Further reading:</p>
<ul class="simple">
<li><a class="reference internal" href="#pergraph"><em>Per Graph</em></a></li>
<li><a class="reference internal" href="#instanceperdependency"><em>Instance Per Dependency</em></a></li>
<li><a class="reference internal" href="#perthread"><em>Per Thread</em></a></li>
<li><a class="reference internal" href="#perhttpsession"><em>Per HTTP Session</em></a></li>
<li><a class="reference internal" href="#hybrid"><em>Hybrid</em></a></li>
<li><a class="reference internal" href="#customlifestyles"><em>Developing a Custom Lifestyle</em></a></li>
</ul>
<div class="section" id="transient">
<span id="id1"></span><h2>Transient<a class="headerlink" href="#transient" title="Permalink to this headline">¶</a></h2>
<div class="note container">
A new instance of the service type will be created for each request (both for calls to <strong>GetInstance&lt;T&gt;</strong> and instances as part of an object graph).</div>
<p>This example instantiates a new <em>IService</em> implementation for each call, while leveraging the power of <a class="reference internal" href="using.html#automatic-constructor-injection"><em>automatic constructor injection</em></a>.</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">,</span> <span class="n">RealService</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Transient</span><span class="p">);</span>

<span class="c1">// Alternatively, you can use the following short cut</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">,</span> <span class="n">RealService</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>The next example instantiates a new <em>RealService</em> instance on each call by using a delegate.</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">RealService</span><span class="p">(</span><span class="k">new</span> <span class="n">SqlRepository</span><span class="p">()),</span>
    <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Transient</span><span class="p">);</span>
</pre></div>
</div>
<div class="note container">
<strong>Note</strong>: It is normally recommended that registrations are made using <strong>Register&lt;TService, TImplementation&gt;()</strong>. It is easier, leads to less fragile configuration, and results in faster retrieval than registrations using a <em>Func&lt;T&gt;</em> delegate. Always try the former approach before resorting to using delegates.</div>
<p>This construct is only required for registering types by a base type or an interface. For concrete transient types, no formal registration is required as concrete types will be automatically registered on request:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">RealService</span><span class="p">&gt;();</span>
</pre></div>
</div>
<div class="note container">
<strong>Warning</strong>: Transient instances are not tracked by the container. This means that Simple Injector will not dispose transient instances.</div>
</div>
<div class="section" id="singleton">
<span id="id2"></span><h2>Singleton<a class="headerlink" href="#singleton" title="Permalink to this headline">¶</a></h2>
<div class="note container">
There will be only one instance of the registered service type during the lifetime of that container instance. Clients will always receive that same instance.</div>
<p>There are multiple ways to register singletons. The most simple and common way to do this is by specifying both the service type and the implementation as generic type arguments. This allows the implementation type to be constructed using automatic constructor injection:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">,</span> <span class="n">RealService</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Singleton</span><span class="p">);</span>
</pre></div>
</div>
<p>You can also use the <em>RegisterSingleton&lt;T&gt;(T)</em> overload to assign a constructed instance manually:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">service</span> <span class="p">=</span> <span class="k">new</span> <span class="n">RealService</span><span class="p">(</span><span class="k">new</span> <span class="n">SqlRepository</span><span class="p">());</span>
<span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleton</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;(</span><span class="n">service</span><span class="p">);</span>
</pre></div>
</div>
<p>There is also an overload that takes an <em>Func&lt;T&gt;</em> delegate. The container guarantees that this delegate is called only once:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">RealService</span><span class="p">(</span><span class="k">new</span> <span class="n">SqlRepository</span><span class="p">()),</span>
    <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Singleton</span><span class="p">);</span>

<span class="c1">// Or alternatively:</span>
<span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleton</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">RealService</span><span class="p">(</span><span class="k">new</span> <span class="n">SqlRepository</span><span class="p">()));</span>
</pre></div>
</div>
<p>Alternatively, when needing to register a concrete type as singleton, you can use the parameterless <strong>RegisterSingleton&lt;T&gt;()</strong> overload. This will inform the container to automatically construct that concrete type (at most) once, and return that instance on each request:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="n">container</span><span class="p">.</span><span class="n">RegisterSingleton</span><span class="p">&lt;</span><span class="n">RealService</span><span class="p">&gt;();</span>

<span class="c1">// Which is a more convenient short cut for:</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">RealService</span><span class="p">,</span> <span class="n">RealService</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Singleton</span><span class="p">);</span>
</pre></div>
</div>
<p>Registration for concrete singletons is necessarily, because unregistered concrete types will be treated as transient.</p>
<div class="note container">
<strong>Note</strong>: Simple Injector will cache a <em>Singleton</em> instance for the lifetime of the <strong>Container</strong> instance and will dispose any auto-wired instance (that implements <em>IDisposable</em>) when <em>Container.Dispose()</em> is called. This includes registrations using <em>RegisterSingleton&lt;TService, TImplementation&gt;()</em> <em>RegisterSingleton&lt;TConcrete&gt;()</em> and <em>RegisterSingleton(Type, Type)</em>. Non-auto-wired instances that are created using factory delegates will be disposed as well. This includes <em>RegisterSingleton&lt;TService&gt;(Func&lt;TService&gt;)</em> and <em>RegisterSingleton(Type, Func&lt;object&gt;)</em>.</div>
<div class="note container">
<strong>Warning</strong>: Already existing instances that are supplied to the container using <em>RegisterSingleton&lt;TService&gt;(TService)</em> and <em>RegisterSingleton(Type, object)</em> will not be disposed by the container. They are considered to be &#8216;externally owned&#8217;.</div>
</div>
<div class="section" id="scoped">
<span id="id3"></span><h2>Scoped<a class="headerlink" href="#scoped" title="Permalink to this headline">¶</a></h2>
<div class="note container">
For every request within an implicitly or explicitly defined scope, a single instance of the service will be returned and that instance will be disposed when the scope ends.</div>
<p>Simple Injector contains five scoped lifestyles:</p>
<ul class="simple">
<li><a class="reference internal" href="#perwebrequest"><em>Per Web Request</em></a></li>
<li><a class="reference internal" href="#perwebapirequest"><em>Per Web API Request</em></a></li>
<li><a class="reference internal" href="#perwcfoperation"><em>Per WCF Operation</em></a></li>
<li><a class="reference internal" href="#perlifetimescope"><em>Per Lifetime Scope</em></a></li>
<li><a class="reference internal" href="#perexecutioncontextscope"><em>Per Execution Context Scope</em></a></li>
</ul>
<p><em>Per Web Request</em>, <em>Per Web API Request</em> and <em>Per WCF Operation</em> implement scoping implicitly, which means that the user does not have to start or finish the scope to allow the lifestyle to end and to dispose cached instances. The <em>Container</em> does this for you. With the <em>Per Lifetime Scope</em> and <em>Per Execution Context Scope</em> lifestyles on the other hand, you explicitly define a scope (just like you would do with .NET&#8217;s TransactionScope class).</p>
<p>Most of the time, you will only use on particular scoped lifestyle per application. To simplify this, Simple Injector allows configuring the default scoped lifestyle in the container. After configuring the default scoped lifestyle, the rest of the configuration can access this lifestyle by calling <strong>Lifestyle.Scoped</strong>, as can be seen in the following example:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="c1">// Set the scoped lifestyle one directly after creating the container</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebApiRequestLifestyle</span><span class="p">();</span>

<span class="c1">// Use the Lifestyle.Scoped everywhere in your configuration.</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserContext</span><span class="p">,</span> <span class="n">AspNetUserContext</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">MyAppUnitOfWork</span><span class="p">&gt;(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">MyAppUnitOfWork</span><span class="p">(</span><span class="s">&quot;constr&quot;</span><span class="p">),</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<p>Just like <em>Singleton</em> registrations, instances of scoped registrations that are created by the container will be disposed when the their scope ends. Scoped lifestyles are especially useful for implementing patterns such as the <a class="reference external" href="http://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a>.</p>
<p>Optionally you can let transient services dispose when a scope ends. Here&#8217;s an example of an extension method that allows registering transient instances that are disposed when the specified scope ends:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">RegisterDisposableTransient</span><span class="p">&lt;</span><span class="n">TService</span><span class="p">,</span> <span class="n">TImplementation</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">Container</span> <span class="n">container</span><span class="p">)</span>
    <span class="k">where</span> <span class="n">TImplementation</span><span class="p">:</span> <span class="n">class</span><span class="p">,</span> <span class="n">IDisposable</span><span class="p">,</span> <span class="n">TService</span>
    <span class="k">where</span> <span class="n">TService</span> <span class="p">:</span> <span class="k">class</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">scoped</span> <span class="p">=</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">reg</span> <span class="p">=</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">Transient</span><span class="p">.</span><span class="n">CreateRegistration</span><span class="p">&lt;</span><span class="n">TService</span><span class="p">,</span> <span class="n">TImplementation</span><span class="p">&gt;(</span><span class="n">container</span><span class="p">);</span>
    <span class="n">reg</span><span class="p">.</span><span class="n">SuppressDiagnosticWarning</span><span class="p">(</span><span class="n">DiagnosticType</span><span class="p">.</span><span class="n">DisposableTransientComponent</span><span class="p">,</span> <span class="s">&quot;suppressed.&quot;</span><span class="p">);</span>
    <span class="n">container</span><span class="p">.</span><span class="n">AddRegistration</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">TService</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
    <span class="n">container</span><span class="p">.</span><span class="n">RegisterInitializer</span><span class="p">&lt;</span><span class="n">TImplementation</span><span class="p">&gt;(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">scoped</span><span class="p">.</span><span class="n">RegisterForDisposal</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">o</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following code snippet show the usage of this extension method:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebRequestLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">RegisterDisposableTransient</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">,</span> <span class="n">ServiceImpl</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>This ensures that each time a <em>ServiceImpl</em> is created by the container, it is registered for disposal when the scope - a web request in this case - ends. This can of course lead to the creation and disposal of multiple <em>ServiceImpl</em> instances during a single request.</p>
<div class="note container">
<strong>Note</strong>: To be able to dispose an instance, the <strong>RegisterForDisposal</strong> will store the reference to that instance in the scope. This means that the instance will be kept alive for the lifetime of that scope.</div>
<div class="note container">
<strong>Note</strong>: Be careful to not register any services for disposal that will outlive that scope (such as services registered as singleton), since a service cannot be used once it has been disposed. This would typically result in <em>ObjectDisposedExceptions</em> and this will cause your application to break.</div>
</div>
<div class="section" id="per-web-request">
<span id="perwebrequest"></span><h2>Per Web Request<a class="headerlink" href="#per-web-request" title="Permalink to this headline">¶</a></h2>
<div class="note container">
Only one instance will be created by the container per web request and the instance will be disposed when the web request ends.</div>
<p>The <a class="reference external" href="https://nuget.org/packages/SimpleInjector.Integration.Web">ASP.NET Integration NuGet Package</a> is available (and available as <strong>SimpleInjector.Integration.Web.dll</strong> in the default download) contains <em>RegisterPerWebRequest</em> extension methods and a <strong>WebRequestLifestyle</strong> class that enable easy <em>Per Web Request</em> registrations:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebRequestLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserRepository</span><span class="p">,</span> <span class="n">SqlUserRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IOrderRepository</span><span class="p">,</span> <span class="n">SqlOrderRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<div class="note container">
<strong>Tip</strong>: For ASP.NET MVC, there&#8217;s a <a class="reference external" href="https://nuget.org/packages/SimpleInjector.MVC3">Simple Injector MVC Integration Quick Start</a> NuGet Package available that helps you get started with Simple Injector in MVC applications quickly.</div>
</div>
<div class="section" id="per-web-api-request">
<span id="perwebapirequest"></span><h2>Per Web API Request<a class="headerlink" href="#per-web-api-request" title="Permalink to this headline">¶</a></h2>
<div class="note container">
Only one instance will be created by the container per request in a ASP.NET Web API application and the instance will be disposed when that request ends (unless specified otherwise).</div>
<p>The <a class="reference external" href="https://nuget.org/packages/SimpleInjector.Integration.WebApi">ASP.NET Web API Integration NuGet Package</a> is available (and available as <strong>SimpleInjector.Integration.WebApi.dll</strong> in the default download) contains <em>RegisterWebApiRequest</em> extension methods and a <strong>WebApiRequestLifestyle</strong> class that enable easy <em>Per Web API Request</em> registrations:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebApiRequestLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserRepository</span><span class="p">,</span> <span class="n">SqlUserRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IOrderRepository</span><span class="p">,</span> <span class="n">SqlOrderRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<div class="note container">
<strong>Tip</strong>: There&#8217;s a <a class="reference external" href="https://nuget.org/packages/SimpleInjector.Integration.WebApi.WebHost.QuickStart">Simple Injector Web API Integration Quick Start</a> NuGet Package available that helps you get started with Simple Injector in Web API applications quickly.</div>
</div>
<div class="section" id="web-api-request-lifestyle-vs-web-request-lifestyle">
<span id="webapirequest-vs-webrequest"></span><h2>Web API Request lifestyle vs. Web Request lifestyle<a class="headerlink" href="#web-api-request-lifestyle-vs-web-request-lifestyle" title="Permalink to this headline">¶</a></h2>
<p>The lifestyles and scope implementations <em>Web Request</em> and <em>Web API Request</em> in SimpleInjector are based on different technologies. <strong>WebApiRequestLifestyle</strong> is derived from <strong>ExecutionContextScopeLifestyle</strong> which works well both inside and outside of IIS. i.e. It can function in a self-hosted Web API project where there is no <em>HttpContext.Current</em>. The scope used by <strong>WebApiRequestLifestyle</strong> is the <strong>ExecutionContextScope</strong>. As the name implies, an execution context scope registers itself in the logical call context and flows with <em>async</em> operations across threads (e.g. a continuation after <em>await</em> on a different thread still has access to the scope regardless of whether <em>ConfigureAwait()</em> was used with <em>true</em> or <em>false</em>).</p>
<p>In contrast, the <strong>Scope</strong> of the <strong>WebRequestLifestyle</strong> is stored within the <em>HttpContext.Items</em> dictionary. The <em>HttpContext</em> can be used with Web API when it is hosted in IIS but care must be taken because it will not always flow with the execution context, because the current <em>HttpContext</em> is stored in the <em>IllogicalCallContext</em> (see <a class="reference external" href="https://blogs.msdn.com/b/pfxteam/archive/2012/06/15/executioncontext-vs-synchronizationcontext.aspx">Understanding SynchronizationContext in ASP.NET</a>). If you use <em>await</em> with <em>ConfigureAwait(false)</em> the continuation may lose track of the original <em>HttpContext</em> whenever the async operation does not execute synchronously. A direct effect of this is that it would no longer be possible to resolve the instance of a previously created service with <strong>WebRequestLifestyle</strong> from the container (e.g. in a factory that has access to the container) - and an exception would be thrown because <em>HttpContext.Current</em> would be null.</p>
<p>The recommendation is therefore to use <strong>WebApiRequestLifestyle</strong> for services that should be &#8216;per Web API request&#8217;, the most obvious example being services that are injected into Web API controllers. <strong>WebApiRequestLifestyle</strong> offers the following benefits:</p>
<ul class="simple">
<li>The Web API controller can be used outside of IIS (e.g. in a self-hosted project)</li>
<li>The Web API controller can execute <em>free-threaded</em> (or <em>multi-threaded</em>) <em>async</em> methods because it is not limited to the ASP.NET <em>SynchronizationContext</em>.</li>
</ul>
<p>For more information, check out the blog entry of Stephen Toub regarding the <a class="reference external" href="https://vegetarianprogrammer.blogspot.de/2012/12/understanding-synchronizationcontext-in.html">difference between ExecutionContext and
SynchronizationContext</a>.</p>
</div>
<div class="section" id="per-wcf-operation">
<span id="perwcfoperation"></span><h2>Per WCF Operation<a class="headerlink" href="#per-wcf-operation" title="Permalink to this headline">¶</a></h2>
<div class="note container">
Only one instance will be created by the container during the lifetime of the WCF service class and the instance will be disposed when the WCF service class is released.</div>
<p>The <a class="reference external" href="https://nuget.org/packages/SimpleInjector.Integration.Wcf">WCF Integration NuGet Package</a> is available (and available as <strong>SimpleInjector.Integration.Wcf.dll</strong> in the default download) contains <strong>RegisterPerWcfOperation</strong> extension methods and a <strong>WcfOperationLifestyle</strong> class that enable easy <em>Per WCF Operation</em> registrations:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WcfOperationLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserRepository</span><span class="p">,</span> <span class="n">SqlUserRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IOrderRepository</span><span class="p">,</span> <span class="n">SqlOrderRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<div class="note container">
<strong>Warning</strong>: Instead of what the name of the <strong>WcfOperationLifestyle</strong> class and the <strong>RegisterPerWcfOperation</strong> methods seem to imply, components that are registered with this lifestyle might actually outlive a single WCF operation. This behavior depends on how the WCF service class is configured. WCF is in control of the lifetime of the service class and contains three lifetime types as defined by the <a class="reference external" href="https://msdn.microsoft.com/en-us/library/system.servicemodel.instancecontextmode.aspx">InstanceContextMode enumeration</a>. Components that are registered <em>PerWcfOperation</em> live as long as the WCF service class they are injected into.</div>
<p>For more information about integrating Simple Injector with WCF, please see the <a class="reference internal" href="wcfintegration.html"><em>WCF integration guide</em></a>.</p>
</div>
<div class="section" id="per-lifetime-scope">
<span id="perlifetimescope"></span><h2>Per Lifetime Scope<a class="headerlink" href="#per-lifetime-scope" title="Permalink to this headline">¶</a></h2>
<div class="note container">
Within a certain (explicitly defined) scope, there will be only one instance of a given service type and the instance will be disposed when the scope ends. A created scope is specific to one particular thread, and can&#8217;t be moved across threads.</div>
<div class="note container">
<strong>Warning</strong>: A lifetime scope can&#8217;t be used for asynchronous operations (using the async/await keywords in C#).</div>
<p>Lifetime Scoping is supported as an extension package for Simple Injector. It is available as <a class="reference external" href="https://nuget.org/packages/SimpleInjector.Extensions.LifetimeScoping">Lifetime Scoping Extensions NuGet package</a> and is part of the default download as <strong>SimpleInjector.Extensions.LifetimeScoping.dll</strong>. The extension package adds multiple <strong>RegisterLifetimeScope</strong> extension method overloads and a <strong>LifetimeScopeLifestyle</strong> class, which allow to register services with the <em>Lifetime Scope</em> lifestyle:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LifetimeScopeLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">,</span> <span class="n">NorthwindContext</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<p>Within an explicitly defined scope, there will be only one instance of a service that is defined with the <em>Lifetime Scope</em> lifestyle:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">using</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">uow1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>
    <span class="kt">var</span> <span class="n">uow2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>

    <span class="n">Assert</span><span class="p">.</span><span class="n">AreSame</span><span class="p">(</span><span class="n">uow1</span><span class="p">,</span> <span class="n">uow2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="note container">
<strong>Warning</strong>: A scope is <em>thread-specific</em>. A single scope should <strong>not</strong> be used over multiple threads. Do not pass a scope between threads and do not wrap an ASP.NET HTTP request with a Lifetime Scope, since ASP.NET can finish a web request on different thread to the thread the request is started on. Use <a class="reference internal" href="#perwebrequest"><em>Per Web Request</em></a> scoping for ASP.NET web applications while running inside a web request. Lifetime scoping however, can still be used in web applications on background threads that are created by web requests or when processing commands in a Windows Service (where each commands gets its own scope). For developing multi-threaded applications, take <a class="reference internal" href="howto.html#multi-threaded-applications"><em>these guidelines</em></a> into consideration.</div>
<p>Outside the context of a lifetime scope, i.e. <cite>using (container.BeginLifetimeScope())</cite> no instances can be created. An exception is thrown when a lifetime scoped registration is requested outside of a scope instance.</p>
<p>Scopes can be nested and each scope will get its own set of instances:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">using</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">outer1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>
    <span class="kt">var</span> <span class="n">outer2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>

    <span class="n">Assert</span><span class="p">.</span><span class="n">AreSame</span><span class="p">(</span><span class="n">outer1</span><span class="p">,</span> <span class="n">outer2</span><span class="p">);</span>

    <span class="k">using</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginLifetimeScope</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">inner1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>
        <span class="kt">var</span> <span class="n">inner2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">AreSame</span><span class="p">(</span><span class="n">inner1</span><span class="p">,</span> <span class="n">inner2</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">AreNotSame</span><span class="p">(</span><span class="n">outer1</span><span class="p">,</span> <span class="n">inner1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="per-execution-context-scope-async-await">
<span id="perexecutioncontextscope"></span><h2>Per Execution Context Scope (async/await)<a class="headerlink" href="#per-execution-context-scope-async-await" title="Permalink to this headline">¶</a></h2>
<div class="note container">
There will be only one instance of a given service type within a certain (explicitly defined) scope and that instance will be disposed when the scope ends (unless specified otherwise). This scope will automatically flow with the logical flow of control of asynchronous methods.</div>
<p>This lifestyle is especially suited for client applications that work with the new asynchronous programming model. For Web API there&#8217;s a <a class="reference internal" href="#perwebapirequest"><em>Per Web API Request lifestyle</em></a> (which actually uses this Execution Context Scope lifestyle under the covers).</p>
<p>Execution Context Scoping is an extension package for Simple Injector. It is available as <a class="reference external" href="https://nuget.org/packages/SimpleInjector.Extensions.ExecutionContextScoping">Execution Context Extensions NuGet package</a> and is part of the default download as <strong>SimpleInjector.Extensions.ExecutionContextScoping.dll</strong>.</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ExecutionContextScopeLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">,</span> <span class="n">NorthwindContext</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<p>Within an explicitly defined scope, there will be only one instance of a service that is defined with the <em>Execution Context Scope</em> lifestyle:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="c1">// using SimpleInjector.Extensions.ExecutionContextScoping;</span>

<span class="k">using</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginExecutionContextScope</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">uow1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>
    <span class="k">await</span> <span class="nf">SomeAsyncOperation</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">uow2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>
    <span class="k">await</span> <span class="nf">SomeOtherAsyncOperation</span><span class="p">();</span>

    <span class="n">Assert</span><span class="p">.</span><span class="n">AreSame</span><span class="p">(</span><span class="n">uow1</span><span class="p">,</span> <span class="n">uow2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="note container">
<strong>Note</strong>: A scope is specific to the asynchronous flow. A method call on a different (unrelated) thread, will get its own scope.</div>
<p>Outside the context of an active execution context scope no instances can be created. An exception is thrown when this happens.</p>
<p>Scopes can be nested and each scope will get its own set of instances:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">using</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginExecutionContextScope</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">var</span> <span class="n">outer1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>
    <span class="k">await</span> <span class="nf">SomeAsyncOperation</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">outer2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>

    <span class="n">Assert</span><span class="p">.</span><span class="n">AreSame</span><span class="p">(</span><span class="n">outer1</span><span class="p">,</span> <span class="n">outer2</span><span class="p">);</span>

    <span class="k">using</span> <span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">BeginExecutionContextScope</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">var</span> <span class="n">inner1</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>

        <span class="k">await</span> <span class="nf">SomeOtherAsyncOperation</span><span class="p">();</span>

        <span class="kt">var</span> <span class="n">inner2</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">IUnitOfWork</span><span class="p">&gt;();</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">AreSame</span><span class="p">(</span><span class="n">inner1</span><span class="p">,</span> <span class="n">inner2</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="n">AreNotSame</span><span class="p">(</span><span class="n">outer1</span><span class="p">,</span> <span class="n">inner1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="per-graph">
<span id="pergraph"></span><h2>Per Graph<a class="headerlink" href="#per-graph" title="Permalink to this headline">¶</a></h2>
<div class="note container">
For each explicit call to <strong>Container.GetInstance&lt;T&gt;</strong> a new instance of the service type will be created, but the instance will be reused within the object graph that gets constructed.</div>
<p>Compared to <strong>Transient</strong>, there will be just a single instance per explicit call to the container, while <strong>Transient</strong> services can have multiple new instances per explicit call to the container. This lifestyle is not supported by Simple Injector but can be simulated by using one of the <a class="reference internal" href="#scoped"><em>Scoped</em></a> lifestyles.</p>
</div>
<div class="section" id="instance-per-dependency">
<span id="instanceperdependency"></span><h2>Instance Per Dependency<a class="headerlink" href="#instance-per-dependency" title="Permalink to this headline">¶</a></h2>
<div class="note container">
Each consumer will get a new instance of the given service type and that dependency is expected to get live as long as its consuming type.</div>
<p>This lifestyle behaves the same as the built-in <strong>Transient</strong> lifestyle, but the intend is completely different. A <strong>Transient</strong> instance is expected to have a very short lifestyle and injecting it into a consumer with a longer lifestyle (such as <strong>Singleton</strong>) is an error. Simple Injector will prevent this from happening by checking for <a class="reference internal" href="LifestyleMismatches.html"><em>lifestyle mismatches</em></a>. With the <em>Instance Per Dependency</em> lifestyle on the other hand, the created component is expected to stay alive as long as the consuming component does. So when the <em>Instance Per Dependency</em> component is injected into a <strong>Singleton</strong> component, we intend it to be kept alive by its consumer.</p>
<p>This lifestyle is deliberately left out of Simple Injector because, its usefulness is very limited compared to the <strong>Transient</strong> lifestyle. It ignores <a class="reference internal" href="LifestyleMismatches.html"><em>lifestyle mismatch checks</em></a> and this can easily lead to errors, and it ignores the fact that application components should be immutable. In case a component is immutable, it&#8217;s very unlikely that each consumer requires its own instance of the injected dependency.</p>
</div>
<div class="section" id="per-thread">
<span id="perthread"></span><h2>Per Thread<a class="headerlink" href="#per-thread" title="Permalink to this headline">¶</a></h2>
<div class="note container">
There will be one instance of the registered service type per thread.</div>
<p>This lifestyle is deliberately left out of Simple Injector because <a class="reference external" href="https://stackoverflow.com/a/14592419/264697">it is considered to be harmful</a>. Instead of using Per Thread lifestyle, you will usually be better of using one of the <a class="reference internal" href="#scoped"><em>Scoped lifestyles</em></a>.</p>
</div>
<div class="section" id="per-http-session">
<span id="perhttpsession"></span><h2>Per HTTP Session<a class="headerlink" href="#per-http-session" title="Permalink to this headline">¶</a></h2>
<div class="note container">
There will be one instance of the registered session per (user) session in a ASP.NET web application.</div>
<p>This lifestyle is deliberately left out of Simple Injector because <a class="reference external" href="https://stackoverflow.com/questions/17702546">it is be used with care</a>. Instead of using Per HTTP Session lifestyle, you will usually be better of by writing a stateless service that can be registered as singleton and let it communicate with the ASP.NET Session cache to handle cached user-specific data.</p>
</div>
<div class="section" id="hybrid">
<span id="id4"></span><h2>Hybrid<a class="headerlink" href="#hybrid" title="Permalink to this headline">¶</a></h2>
<div class="note container">
A hybrid lifestyle is a mix between two or more lifestyles where the the developer defines the context for which the wrapped lifestyles hold.</div>
<p>Simple Injector has no built-in hybrid lifestyles, but has a simple mechanism for defining them:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">CreateHybrid</span><span class="p">(</span>
    <span class="n">lifestyleSelector</span><span class="p">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">container</span><span class="p">.</span><span class="n">GetCurrentLifetimeScope</span><span class="p">()</span> <span class="p">!=</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">trueLifestyle</span><span class="p">:</span> <span class="k">new</span> <span class="n">LifetimeScopeLifestyle</span><span class="p">(),</span>
    <span class="n">falseLifestyle</span><span class="p">:</span> <span class="k">new</span> <span class="n">WebRequestLifestyle</span><span class="p">());</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserRepository</span><span class="p">,</span> <span class="n">SqlUserRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ICustomerRepository</span><span class="p">,</span> <span class="n">SqlCustomerRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
<p>In the example a hybrid lifestyle is defined wrapping the <a class="reference internal" href="#perwebrequest"><em>Web Request</em></a> lifestyle and the <a class="reference internal" href="#perlifetimescope"><em>Per Lifetime Scope</em></a> lifestyle. The supplied <em>lifestyleSelector</em> predicate returns <em>true</em> when the container should use the <em>Lifetime Scope</em> lifestyle and <em>false</em> when the <em>Web Request</em> lifestyle should be selected.</p>
<p>A hybrid lifestyle is useful for registrations that need to be able to dynamically switch lifestyles throughout the lifetime of the application. The shown hybrid example might be useful in a web application, where some operations need to be run in isolation (which their own instances of scoped registrations such as unit of works) or run outside the context of an <em>HttpContext</em> (in a background thread for instance).</p>
<p>Please note though that when the lifestyle doesn&#8217;t have to change throughout the lifetime of the application, a hybrid lifestyle is not needed. A normal lifestyle can be registered instead:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">runsOnWebServer</span> <span class="p">=</span> <span class="n">ReadConfigurationValue</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;(</span><span class="s">&quot;RunsOnWebServer&quot;</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>
<span class="n">container</span><span class="p">.</span><span class="n">Options</span><span class="p">.</span><span class="n">DefaultScopedLifestyle</span> <span class="p">=</span>
    <span class="n">runsOnWebServer</span> <span class="p">?</span> <span class="k">new</span> <span class="n">WebRequestLifestyle</span><span class="p">()</span> <span class="p">:</span> <span class="k">new</span> <span class="n">LifetimeScopeLifestyle</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserRepository</span><span class="p">,</span> <span class="n">SqlUserRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ICustomerRepository</span><span class="p">,</span> <span class="n">SqlCustomerRepository</span><span class="p">&gt;(</span><span class="n">Lifestyle</span><span class="p">.</span><span class="n">Scoped</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="developing-a-custom-lifestyle">
<span id="customlifestyles"></span><h2>Developing a Custom Lifestyle<a class="headerlink" href="#developing-a-custom-lifestyle" title="Permalink to this headline">¶</a></h2>
<p>The lifestyles supplied by Simple Injector should be sufficient for most scenarios, but in rare circumstances defining a custom lifestyle might be useful. This can be done by creating a class that inherits from <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/T_SimpleInjector_Lifestyle.htm">Lifestyle</a> and let it return <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/T_SimpleInjector_Registration.htm">Custom Registration</a> instances. This however is a lot of work, and a shortcut is available in the form of the <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/M_SimpleInjector_Lifestyle_CreateCustom.htm">Lifestyle.CreateCustom</a>.</p>
<p>A custom lifestyle can be created by calling the <strong>Lifestyle.CreateCustom</strong> factory method. This method takes two arguments: the name of the lifestyle to create (used mainly for display in the <a class="reference internal" href="diagnostics.html"><em>Diagnostic Services</em></a>) and a <a class="reference external" href="https://simpleinjector.org/ReferenceLibrary/?topic=html/T_SimpleInjector_CreateLifestyleApplier.htm">CreateLifestyleApplier</a> delegate:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="k">public</span> <span class="k">delegate</span> <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">CreateLifestyleApplier</span><span class="p">(</span>
    <span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span> <span class="n">transientInstanceCreator</span><span class="p">)</span>
</pre></div>
</div>
<p>The <strong>CreateLifestyleApplier</strong> delegate accepts a <em>Func&lt;object&gt;</em> that allows the creation of a transient instance of the registered type. This <em>Func&lt;object&gt;</em> is created by Simple Injector supplied to the registered  <strong>CreateLifestyleApplier</strong> delegate for the registered type. When this <em>Func&lt;object&gt;</em> delegate is called, the creation of the type goes through the <a class="reference internal" href="pipeline.html"><em>Simple Injector pipeline</em></a>. This keeps the experience consistent with the rest of the library.</p>
<p>When Simple Injector calls the <strong>CreateLifestyleApplier</strong>, it is your job to return another <em>Func&lt;object&gt;</em> delegate that applies the caching based on the supplied <em>instanceCreator</em>. A simple example would be the following:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">sillyTransientLifestyle</span> <span class="p">=</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">CreateCustom</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Silly Transient&quot;</span><span class="p">,</span>
    <span class="c1">// instanceCreator is of type Func&lt;object&gt;</span>
    <span class="n">lifestyleApplierFactory</span><span class="p">:</span> <span class="n">instanceCreator</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">// A Func&lt;object&gt; is returned that applies caching.</span>
        <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">instanceCreator</span><span class="p">.</span><span class="n">Invoke</span><span class="p">();</span>
        <span class="p">};</span>
    <span class="p">});</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">,</span> <span class="n">MyService</span><span class="p">&gt;(</span><span class="n">sillyTransientLifestyle</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we create a custom lifestyle that applies no caching and simply returns a delegate that will on invocation always call the wrapped <em>instanceCreator</em>. Of course this would be rather useless and using the built-in <strong>Lifestyle.Transient</strong> would be much better in this case. It does however demonstrate its use.</p>
<p>The <em>Func&lt;object&gt;</em> delegate that you return from your <strong>CreateLifestyleApplier</strong> delegate will get cached by Simple Injector per registration. Simple Injector will call the delegate once per registration and stores the returned <em>Func&lt;object&gt;</em> for reuse. This means that each registration will get its own <em>Func&lt;object&gt;</em>.</p>
<p>Here&#8217;s an example of the creation of a more useful custom lifestyle that caches an instance for 10 minutes:</p>
<div class="highlight-c#"><div class="highlight"><pre><span class="kt">var</span> <span class="n">tenMinuteLifestyle</span> <span class="p">=</span> <span class="n">Lifestyle</span><span class="p">.</span><span class="n">CreateCustom</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Absolute 10 Minute Expiration&quot;</span><span class="p">,</span>
    <span class="n">lifestyleApplierFactory</span><span class="p">:</span> <span class="n">instanceCreator</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="n">TimeSpan</span> <span class="n">timeout</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">syncRoot</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">expirationTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">MinValue</span><span class="p">;</span>
        <span class="kt">object</span> <span class="n">instance</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

        <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">syncRoot</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">expirationTime</span> <span class="p">&lt;</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">instance</span> <span class="p">=</span> <span class="n">instanceCreator</span><span class="p">.</span><span class="n">Invoke</span><span class="p">();</span>
                    <span class="n">expirationTime</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">});</span>

<span class="kt">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Container</span><span class="p">();</span>

<span class="c1">// We can reuse the created lifestyle for multiple registrations.</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IService</span><span class="p">,</span> <span class="n">MyService</span><span class="p">&gt;(</span><span class="n">tenMinuteLifestyle</span><span class="p">);</span>
<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">AnotherService</span><span class="p">,</span> <span class="n">MeTwoService</span><span class="p">&gt;(</span><span class="n">tenMinuteLifestyle</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example the <strong>Lifestyle.CreateCustom</strong> method is called and supplied with a delegate that returns a delegate that applies the 10 minute cache. This example makes use of the fact that each registration gets its own delegate by using four closures (timeout, syncRoot, expirationTime and instance). Since each registration (in the example <em>IService</em> and <em>AnotherService</em>) will get its own <em>Func&lt;object&gt;</em> delegate, each registration gets its own set of closures. The closures are therefore static per registration.</p>
<p>One of the closure variables is the <em>instance</em> and this will contain the cached instance that will change after 10 minutes has passed. As long as the time hasn&#8217;t passed, the same instance will be returned.</p>
<p>Since the constructed <em>Func&lt;object&gt;</em> delegate can be called from multiple threads, the code needs to do its own synchronization. Both the DateTime comparison and the DateTime assignment are not thread-safe and this code needs to handle this itself.</p>
<p>Do note that even though locking is used to synchronize access, this custom lifestyle might not work as expected, because when the expiration time passes while an object graph is being resolved, it might result in an object graph that contains two instances of the registered component, which might not be what you want. This example therefore is only for demonstration purposes.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="integration.html" class="btn btn-neutral float-right" title="Integration Guide"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="using.html" class="btn btn-neutral" title="Using Simple Injector"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Simple Injector Contributors.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>